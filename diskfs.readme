Идеи по реализации дисковой файловой системы.


1. Представление данных на диске.

   Все данные хранятся в виде двух B+ COW деревьев. Одно для объектов ФС
(иноды, записи катлогов), а другое для управления свободным пространством
(занятые экстенты).


2. Транзакции

   Транзакции позволяют накапливать изменения вместе и записывать их на диск
в консистентном виде. В нашем случае используются COW, поэтому каждая
транзакция завершается записью корней деревьев на диск, все остальные данные
могут писаться в любом порядке, но до того как мы запишем ссылку на корни на
диск.

   Каждая транзакция имеет ограниченный размер, в зависимости от свободного
места в транзакции мы либо решаем запустить новую транзакцию, либо
присоединиться к уже существующей транзакции.

   Внутри одной транзакции все писатели параллельно модифицируют общие данные,
поэтому должна быть предусмотрена синхронизация. Для B+ COW деревьев все
модификации осуществляются за один проход от корня к листу, поэтому самый
простой подход к синхронизации это обычнаф блокировка от корня (в каждый момент
времени мы держим блок на родителя и на текущий узел, первый не дает
конкурирующим писателям испортить родителя, второй нужен только, чтобы
дождаться завершения работы с текущим узлом писателя впереди нас).

   Как только все писатели завершат транзакцию ее можно сбрасывать на диск либо
подождать других писателей. Для принятия решения мы можем смотреть на размер
транзакции или время ее жизни. Как только все читатели закончат транзакцию
транзакцию можно удалять.

   Пользователи пишушие слишком много данных за раз, т. е. столько что в одну
транщакцию они не поместяться, должны разделить данные на блоки и писать их в
разных транщакциях. К счатью классический Unix-овый интерфейс не требует, чтобы
все данные были записаны за один раз.

   Каждая транзакция хранит список "грязных" болоков, т. е. блоков, которые
нужно записать на диск, а также список освобожденных блоков (в результате COW у
нас обязательно будут получать такие блоки, кроме того они будут появляться при
удалении объектов из ФС).


3. Управление свободным местом

   Информация о занятых участках диска хранится в отдельном дереве, которое
тоже является COW деревом, так что в памяти аллоцированной для транзакции
нужно предусмотреть место для дерева занятых экстентов. По мере необходимости
мы можем аллоцировать новые экстенты для транзакции, но основная идея в том,
чтобы выделять большие последотвальные участки диска, т. е. лучше заранее
выделить под транзакции достаточно большой участок (порядка 1M) диска. Если
этого окажется слишком много, мы всегда сможем обрезать его с конца, так как
экстенты всегда заполняются последовательно. Кроме того большие экстенты не
позволят этому дереву разрастаться слишком большим.

   Чтобы найти свободный участок на диске нужно обойти дерево и найти в нем
"дыру". Поэтому важно, чтобы дерево не было слишком большим. Результаты такого
обхода можно кешировать в памяти.

   Для каждого экстента необходимо предусмотреть сечтчик ссылок - количество
объектов (или блоков?), которые в нем хранятся. Как только счетчик ссылок
дойдет до нуля мы можем освободить этот экстент (т. е. удалить его из дерева
экстентов). Экстент либо полностью считается либо полностью занятым либо
свободным - мы не будем освобждать порции экстента (такой подход не даст
разрастись дереву экстентов, но с другой стороны при большой фрагментации может
стать проблемой; для полноценного использования можно предусмотреть возможность
дефрагментации экстентов - перенос данных из почти свободных экстентов в другие
экстенты).


4. Кеширование в памяти

   Каждое дерево частично кешируется в памяти и все пользователи пользуются
единым интерфейсом для обращения к нему. Это нужно для того, чтобы все
пользователи имели согласованное представление о структуре дерева. Кроме того
деревья разделяют общий кеш блоков диска.
